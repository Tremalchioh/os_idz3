# ИДЗ №3 по ОС, Вариант 8

# Куртаев Альберт Фанисович БПИ227

## 4-5 Баллов
Разработать клиент-серверное приложение, в котором сервер и клиенты независимо друг от друга отображают только ту информацию, которая поступает им во время обмена. Требуется смоделировать поведение обедающих философов, синхронизируемых посредством сервера, который фиксирует состояние стола и организует взаимодействие с философами. При запуске программ IP-адреса и порты задаются в командной строке

1. **Создание серверной программы**:
    - Сервер управляет состоянием вилок
    - Обрабатывает запросы философов на получение и освобождение вилок
    - Отправляет философам результаты их запросов

2. **Создание клиентской программы для философов**:
    - Философы запрашивают вилки у сервера для приема пищи
    - Сообщают серверу об освобождении вилок после приема пищи
    - Периодически думают и едят, время этих действий задается случайным образом
    - Отображают в консоли результаты своих действий (размышляют, едят)

3. **Взаимодействие между сервером и клиентами**:
    - Использование сокетов TCP для связи между сервером и клиентами
    - Сервер прослушивает входящие подключения на заданном порту
    - Клиенты подключаются к серверу и отправляют запросы

## Компиляция и запуск программы

### Используемый компилятор

Для компиляции программы использовался компилятор Clang

### Компиляция серверной программы

```sh 
clang++ -std=c++11 -o table table.cpp -pthread
```
### Компиляция клиентской программы

```sh
clang++ -std=c++11 -o client client.cpp -pthread
```

### Запуск серверной программы в отдельном терминале

```sh
./table
```

### Компиляция клиентской программы

```sh
clang++ -std=c++11 -o client client.cpp -pthread
```

### Запуск клиентских программ для философов в другом терминале
#### <server_ip> Выбираем, какой нужен. Я выбирал адрес локальной сети
```sh
./client <server_ip> 0 &
./client <server_ip> 1 &
./client <server_ip> 2 &
./client <server_ip> 3 &
./client <server_ip> 4 &
```

### Завершение программ
#### Завершение программ выполняем данной командой, вставив нужный <PID>, который выводится в консоль после каждого запуска новой программы
```sh
kill -9 <PID>
``` 
Например:
```sh
./client 172.19.174.18 1 &
[1] 73289
```
Завершаем программу
```sh
kill -9 73289
```
Также необходимо найти PID процесса сервера командой 
```
ps aux | grep table
```
и таким же способом его завершить.


### Место для скриншотов
![Вывод клиентов](./client-log.png)




## 6-7-8 Баллов.
Разработать клиент-серверное приложение, в котором сервер и клиенты независимо друг от друга отображают только ту информацию, которая поступает им во время обмена. Требуется смоделировать поведение обедающих философов, синхронизируемых посредством сервера, который фиксирует состояние стола и организует взаимодействие с философами. При запуске программ IP-адреса и порты задаются в командной строке

Необходимо также разработать отдельную клиентскую программу, подключаемую к серверу, которая предназначена для отображения комплексной информации о выполнении приложения в целом


1. **Создание серверной программы**:
    - Сервер управляет состоянием вилок
    - Обрабатывает запросы философов на получение и освобождение вилок
    - Отправляет философам результаты их запросов
    - Отправляет текущие состояния системы клиентам-мониторам

2. **Создание клиентской программы для философов**:
    - Философы запрашивают вилки у сервера для приема пищи
    - Сообщают серверу об освобождении вилок после приема пищи
    - Периодически думают и едят, время этих действий задается случайным образом
    - Отображают в консоли результаты своих действий (размышляют, едят)

3. **Создание клиентской программы для мониторинга**:
    - Подключается к серверу и получает информацию о текущем состоянии системы.
    - Отображает полученную информацию в реальном времени.

4. **Взаимодействие между сервером и клиентами**:
    - Использование сокетов TCP для связи между сервером и клиентами.
    - Сервер прослушивает входящие подключения на заданном порту.
    - Клиенты подключаются к серверу и отправляют запросы.
    - Мониторы подключаются к серверу и получают информацию о текущем состоянии системы.


## Компиляция и запуск программы.

### Используемый компилятор.

Для компиляции программы использовался компилятор Clang.

### Компиляция серверной программы.

```sh 
clang++ -std=c++11 -o table table.cpp -pthread
```
### Компиляция клиентской программы.

```sh
clang++ -std=c++11 -o client client.cpp -pthread
```

### Компиляция монитора.

```sh
clang++ -std=c++11 -o info info.cpp -pthread
```


### Запуск серверной программы в отдельном терминале.

```sh
./table
```

### Запуск клиентских программ для философов в другом терминале.
#### <server_ip> Выбираем, какой нужен. Я выбирал адрес локальной сети.
```sh
./client <server_ip> 0 &
./client <server_ip> 1 &
./client <server_ip> 2 &
./client <server_ip> 3 &
./client <server_ip> 4 &
```

### Подключение монитора для философов в третьем терминале.
```sh
./info <server_ip>
```

### Завершение программ.
#### Завершение программ выполняем данной командой, вставив нужный <PID>, который выводится в консоль после каждого запуска новой программы.
```sh
kill -9 <PID>
``` 
Например:
```sh
./client 172.19.174.18 1 &
[1] 73289
```
Завершаем программу
```sh
kill -9 73289
```
Также необходимо найти PID процесса сервера командой 
```
ps aux | grep table
```
и таким же способом его завершить.

### Место для скриншотов.
![Вывод одного из мониторов](./monitor-log.png)
![Вывод клиентов](./client-log.png)



## 10 Баллов.
Разработать клиент-серверное приложение, в котором сервер и клиенты независимо друг от друга отображают только ту информацию, которая поступает им во время обмена. Требуется смоделировать поведение обедающих философов, синхронизируемых посредством сервера, который фиксирует состояние стола и организует взаимодействие с философами. При запуске программ IP-адреса и порты задаются в командной строке.

Необходимо также разработать отдельную клиентскую программу, подключаемую к серверу, которая предназначена для отображения комплексной информации о выполнении приложения в целом. Клиентов-наблюдателей можно подключать и отключать в динамическом режиме без нарушения работы всего приложения.

Также при завершении работы сервера должно происходить корректное завершение работы всех подключенных клиентов.

## Алгоритм выполнения задачи.

1. **Создание серверной программы**:
    - Сервер управляет состоянием вилок.
    - Обрабатывает запросы философов на получение и освобождение вилок.
    - Отправляет философам результаты их запросов.
    - Отправляет текущие состояния системы клиентам-мониторам.
    - Уведомляет всех клиентов о завершении работы при остановке сервера.

2. **Создание клиентской программы для философов**:
    - Философы запрашивают вилки у сервера для приема пищи.
    - Сообщают серверу об освобождении вилок после приема пищи.
    - Периодически думают и едят, время этих действий задается случайным образом.
    - Отображают в консоли результаты своих действий (размышляют, едят).
    - Завершают работу при получении специального уведомления от сервера.

3. **Создание клиентской программы для мониторинга**:
    - Подключается к серверу и получает информацию о текущем состоянии системы.
    - Отображает полученную информацию в реальном времени.
    - Завершает работу при получении специального уведомления от сервера.

4. **Взаимодействие между сервером и клиентами**:
    - Использование сокетов TCP для связи между сервером и клиентами.
    - Сервер прослушивает входящие подключения на заданном порту.
    - Клиенты подключаются к серверу и отправляют запросы.
    - Мониторы подключаются к серверу и получают информацию о текущем состоянии системы.
5. **Завершение программ**:
    - Сервер посылает сообщение "shutdown" всем мониторам и клиентам.
    - Клиенты самостоятельно завершаются при получении от сервера сообщения "shutdown".
    - Мониторы самостоятельно завершаются при получении от сервера сообщения "shutdown".

## Компиляция и запуск программы.

### Используемый компилятор.

Для компиляции программы использовался компилятор Clang.

### Компиляция серверной программы.

```sh 
clang++ -std=c++11 -o table table.cpp -pthread
```
### Компиляция клиентской программы.

```sh
clang++ -std=c++11 -o client client.cpp -pthread
```

### Компиляция монитора.

```sh
clang++ -std=c++11 -o info info.cpp -pthread
```


### Запуск серверной программы в отдельном терминале.

```sh
./table
```

### Запуск клиентских программ для философов в другом терминале.
#### <server_ip> Выбираем, какой нужен. Я выбирал адрес локальной сети.
```sh
./client <server_ip> 0 &
./client <server_ip> 1 &
./client <server_ip> 2 &
./client <server_ip> 3 &
./client <server_ip> 4 &
```

### Подключение монитора для философов в третьем терминале
```sh
./info <server_ip>
```

## Завершение работы программ

### Завершение работы сервера

При нажатии `Ctrl+C` в терминале, где запущен сервер, сервер получает сигнал `SIGINT`, который обрабатывается функцией `shutdown_server`. Эта функция выполняет следующие действия:

1. Устанавливает флаг `running` в `false`, что позволяет выйти из основного цикла сервера
2. Вызывает функцию `notify_shutdown`, которая отправляет сообщение "shutdown" всем подключенным клиентам и мониторинговым программам
3. Вызывает `shutdown(server_fd, SHUT_RDWR)` для закрытия сокета сервера и выхода из блокирующего вызова `accept`

После выхода из основного цикла сервер закрывает сокет и завершает свою работу

### Действия клиента-философа при завершении

Каждый клиент-философ в своем цикле ожидает сообщения от сервера. Когда сервер отправляет сообщение "shutdown", клиент-философ выполняет следующие действия:

1. Получает сообщение "shutdown" от сервера
2. Выводит сообщение "Server abort. Philosopher <номер> exiting."
3. Закрывает сокет и завершает выполнение программы с помощью `exit(0)`

### Действия клиента мониторинга при завершении.

Клиент мониторинга, аналогично клиентам-философам, ожидает сообщения от сервера. Когда сервер отправляет сообщение "shutdown", клиент мониторинга выполняет следующие действия:

1. Получает сообщение "shutdown" от сервера
2. Выводит сообщение "Server shutdown. Monitor exiting."
3. Закрывает сокет и завершает выполнение программы с помощью `exit(0)`

### Место для скриншотов
![Вывод одного из мониторов](./monitor-log.png)
![Вывод клиентов](./client-log.png)
![Завершение работы сервера](./server-abort.png)
![Завершение работы одного из клиентов](./client-abort.png)
![Завершение работы одного из мониторов](./monitor-abort.png)

